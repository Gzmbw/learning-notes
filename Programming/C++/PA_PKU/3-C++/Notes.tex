%-*- coding: UTF-8 -*-
% Notes.tex
%
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\geometry{a4paper, centering, scale=0.8}
\usepackage{minted}
\usepackage{hyperref}

\title{\heiti 《程序设计与算法》——《C++ 程序设计》学习笔记}
\author{\kaishu Du Ang \\ \texttt{du2ang233@gmail.com} }
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section{C 语言中的高级内容——从 C 走进 C++}
\subsection{函数指针}
\subsubsection{函数指针的定义}
程序运行期间，每个函数都会占用一段连续的内存空间。而函数名就是该函数所占内存区域的起始地址（也称“入口地址”）。将入口地
址赋给一个指针变量，那该指针就指向了这个函数，这种指向函数的指针变量称为“函数指针”。我们可以通过函数指针来调用函数。

定义函数指针：类型名 (*指针变量名)(参数类型1, 参数类型2, ...)

例如：\mintinline{C++}{int (*pf)(int, char);} 表示 \texttt{pf} 是一个函数指针，它所指向的函数返回类型是
\texttt{int}，该函数应有两个参数，第一个是 \texttt{int} 类型，第二个是 \texttt{char} 类型。

\subsubsection{函数指针和 qsort 库函数}
为什么要定义函数指针呢？干嘛不直接用函数名来调用？

如果要对数组排序，需要知道：
\begin{itemize}
    \item 数组的起始地址
    \item 数组元素的个数
    \item 每个元素的大小（由此可以算出每个元素的地址）
    \item 元素谁在前谁在后的规则
\end{itemize}

C 语言快速排序库函数可以对任意类型的数组进行排序：
\begin{minted}{C++}
    void qsort(void *base, int nelem, usigned int width,
        int (*pfCompare)(const viod *, cont void *));
\end{minted}

\begin{itemize}
    \item \texttt{base}: 待排数组的起始地址
    \item \texttt{nelem}: 带排序数组的元素个数
    \item \texttt{width}: 待排序数组的每个元素的大小（以字节为单位）
    \item \texttt{pfCompare}: 比较函数（程序员自己编写）的地址
\end{itemize}

\begin{minted}{C++}
    int compare(const void *elem1, const void *elem2);    // 比较函数
\end{minted}

比较函数的编写规则：
\begin{enumerate}
    \item 如果 \texttt{*elem1} 应该排在 \texttt{*elem2} 前面，则函数返回值是负整数
    \item 如果 \texttt{*elem1} 和 \texttt{*elem2} 哪个排在前面都行，那么函数返回 0
    \item 如果 \texttt{*elem1} 应该排在 \texttt{*elem2} 后面，则函数返回值是正整数
\end{enumerate}

一个比较函数的示例：
\begin{minted}{C++}
    int myCompare(const void *elem1, const void *elem2)
    {
        unsigned int *p1, *p2;
        p1 = (unsigned int *) elem1;    // 只写“*elem1” 非法，编译器不知道其类型和大小
        p2 = (unsigned int *) elem2;
        return (*p1 % 10) - (*p2 % 10); // 个位数小的排在前面
    }
\end{minted}

\subsection{命令行参数}
将用户在命令行窗口输入可执行文件名的方式启动程序时，跟在可执行文件后面的那些字符串，称为“命令行参数”。命令行参数可以有
多个，以空格分隔。

\begin{minted}{C++}
    int main(int argc, char *argv[])
    {
        ...
    }
\end{minted}

\texttt{argc}: 代表程序启动时，命令行参数的个数。执行程序本身的文件名是第一个命令行的参数。
\texttt{argv}: 指针数组，其中的每个元素都是一个 \texttt{char *} 类型的指针，该指针指向存放命令行参数的字符串。

\begin{minted}{C++}
    int main(int argc, char const *argv[]) {
        for (int i = 0; i < argc; i++) {
            cout << argv[i] << " ";
        }
        cout << endl;
        return 0;
    }
\end{minted}

如果参数中包含空格，需要将参数用 \texttt{"..."} 引起来

输入：\mintinline{bash}{./CmdArguments hello world "hello world"}

输出：\mintinline{bash}{./CmdArguments hello world hello world}

\subsection{位运算}
位运算：对于整数类型（\texttt{int}、\texttt{char}、\texttt{long} 等）变量中的某一位（bit），或者若干位进行操作。

C/C++ 语言提供了六种位运算符来进行位运算操作：
\begin{itemize}
    \item \texttt{\&} 按位与（双目）
    \item \texttt{|} 按位或（双目）
    \item \texttt{\^{}} 按位异或（双目）
    \item \texttt{$\sim$} 按位非（取反）（单目）
    \item \texttt{<<} 左移（双目）
    \item \texttt{>>} 右移（双目）
\end{itemize}

\subsubsection{按位与 \texttt{\&}}
通常用按位与来将某变量中的某些位清 0 且同时保留其他位不变。
\begin{minted}{C++}
    n = n & 0xffffff00; // 将 int 类型的 n 的低 8 位全部置 0
    n &= 0xffffff00;
    n &= 0xff00;        // 将 short 类型的 n 的低 8 位全部置 0
\end{minted}

也可以用按位与来获取某变量中的某一位。例如我们想判断 \texttt{int} 型变量 \texttt{n} 的右数第 7 位是否为 1，只需看
表达式 \mintinline{C++}{n & 0x80} 的值是否等于 \texttt{0x80} 即可。

\subsubsection{按位或 \texttt{|}}
按位或通常用来将某变量中的某些位置 1 且保持其他位不变。
\begin{minted}{C++}
    n |= 0xff;  // 将 int 型变量 n 的低 8 位全置成1
\end{minted}

\subsubsection{按位异或 \texttt{\^{}}}
按位异或运算通常用来将某变量中的某些位取反，且保持其他位不变。
\begin{minted}{C++}
    n ^= 0xff;  // 将 int 型变量 n 的低 8 位取反
\end{minted}

异或运算的特点：如果 $a$ \^{} $b = c$，那么 $c$ \^{} $b = a$，$c$ \^{} $a = b$。（穷举法可证）

可以利用此规律用来进行最简单的加密和解密。

另外异或运算还能实现不通过临时变量，就能交换两个变量的值：
\begin{minted}{C++}
    int a = 5, b = 7;
    a = a ^ b;
    b = b ^ a;
    a = a ^ b;
\end{minted}

\subsubsection{按位非 \texttt{$\sim$}}
按位非运算符 \texttt{$\sim$} 是单目运算符，其功能是将操作数中的二进制位 0 变成 1，1 变成 0。

\subsubsection{左移 \texttt{<<}}
表达式 \mintinline{C++}{a << b} 的值是将 \texttt{a} 各二进制位全部左移 \texttt{b} 位后得到的值。左移时，高位
丢弃，低位补 0。注意 \texttt{<<} 是双目运算符，这里是一个表达式，\texttt{a} 的值不因运算而改变。

实际上，左移 1 位，就等于是乘 2，左移 n 位，就等于乘 $2^n$。而左移操作比乘法操作快得多。

\subsubsection{右移\texttt{>>}}
表达式 \mintinline{C++}{a >> b} 的值是：将 \texttt{a} 各二进制位全部右移 \texttt{b} 位后得到的值。右移时，移
出最右边的位就被丢弃。同样地，\texttt{a} 的值不因右移运算而改变。

对于无符号数，右移时高位补 0。对于有符号数，如 \texttt{long}、\texttt{int}、\texttt{short}、\texttt{char}
类型变量，在右移时，符号位（即最高位）将一起移动，并且大多数 C/C++ 编译器规定，如果原符号位为 1，则右移时最高位就补充
1，原符号位为 0，则右移时高位就补充 0。

实际上，右移 n 位，就相当于左操作数除以 $2^n$。但是有时候不能除尽，需要将结果往小里取整。

思考题：有两个 \texttt{int} 型的变量 \texttt{a} 和 \texttt{n}（\texttt{0 <= n <= 31}），要求写一个表达式，
使该表达式的值和 \texttt{a} 的第 \texttt{n} 位相同。

答案：\mintinline{C++}{(a >> n) & 1} \qquad 如果 \texttt{n} 不为 31，答案还可以是
\mintinline{C++}{(a & (1 << n)) >> n}

\subsection{引用}
\subsubsection{引用的定义}
定义：\mintinline{C++}{类型名 &引用名 = 某变量名;}
\begin{minted}{C++}
    int n = 4;
    int &r = n; // r 引用了 n，r 的类型是 int &
\end{minted}
某个变量的引用，等价于这个变量，相当于该变量的别名。

示例代码：
\begin{minted}{C++}
    int n = 7;
    int &r = n;
    r = 4;
    cout << r << endl;  // 4
    cout << n << endl;  // 4
    n = 5;
    cout << r << endl;  // 5
\end{minted}

注意：
\begin{itemize}
    \item 定义引用时一定要将其初始化成引用某个变量
    \item 初始化后，它就一直引用该变量，不会再引用别的变量了
    \item 引用只能引用变量，不能引用常量和表达式
\end{itemize}

\subsubsection{引用的简单示例}
交换两个变量的值：
\begin{minted}{C++}
    void swapByReference(int &a, int &b)
    {
        int temp;
        temp = a;
        a = b;
        b = temp;
    }
    int main(int argc, char const *argv[]) {
        int n1 = 3, n2 = 5;
        swapByReference(n1, n2);
        cout << n1 << " " << n2 << endl;    // 5 3
        return 0;
    }
\end{minted}

引用作为函数的返回值：
\begin{minted}{C++}
    int n = 4;

    int &setValue()
    {
        return n;
    }

    int main(int argc, char const *argv[]) {
        setValue() = 40;
        cout << n << endl;
        return 0;
    }
\end{minted}

常引用：
\begin{minted}{C++}
    int n = 100;
    const int &r = n;
    // r = 200; // error: cannot assign to variable 'r' with const-qualified type 'const int &'
    n = 300;    // OK
    cout << n << endl;  // 300
    return 0;
\end{minted}

\mintinline{C++}{const T &} 和 \mintinline{C++}{T &} 是不同的类型，分别是常引用和非常引用。

常引用和非常引用的转换：
\begin{itemize}
    \item \mintinline{C++}{const T} 类型的引用或 \mintinline{C++}{T} 类型的变量可以用来初始化
    \mintinline{C++}{const T &} 类型的引用。
    \item \mintinline{C++}{const T} 类型的常变量和 \mintinline{C++}{const T &} 类型的引用则不能用来初始化
    \mintinline{C++}{T &} 类型的引用，除非进行强制类型转换。
\end{itemize}

\subsection{\mintinline{C++}{const} 关键字的用法}
\subsubsection{定义常量}
\begin{minted}{C++}
    const int MAX_VAL = 23;
    const double PI = 3.14;
    const char *SCHOOL_NAME = "Ocean University of China";
\end{minted}

\mintinline{C++}{#define} 也可以用来定义常量，但应该多使用 \mintinline{C++}{const}，少用
\mintinline{C++}{#define}，因为 \mintinline{C++}{const} 是有类型的，便于类型检查。

\subsubsection{定义常量指针}
在声明一个指针的时候，在其类型前面加上 \mintinline{C++}{const} 限定符，这个指针就成为常量指针。

当我们通过常量指针来访问它所指向的内容的时候，不管它指向的内容实际上是否为常量，常量指针都认为它是常量。因此，不可以通
过常量指针修改其指向的内容：
\begin{minted}{C++}
    int n, m;
    const int *p = &n;
    // *p = 5;  // error: read-only variable is not assignable
    n = 4;      // OK
    p = &m;     // OK
\end{minted}

不能把常量指针赋给非常量指针（除非强制类型转换），但反过来可以。因为常量指针认为自己指向的内容是常量，神圣不容修改，如果
把这些内容的地址交给非常量指针，内容就有可能被修改，这太危险了，坚决不能给。非常量的指针指向的内容是可以被修改的，非常
量指针要把这些内容给常量指针，常量指针就会说“可以啊，就算把地址给我也不会去修改它的”。
\begin{minted}{C++}
    const int *p1;
    int *p2;
    p1 = p2;    // OK
    p2 = p1;    // error: assigning to 'int *' from incompatible type 'const int *'
    p2 = (int *)p1; // OK, cast type
\end{minted}

由于这个指针本身不是常量（指针常量），所以这个指针可以重新指向其他的内容：
\begin{minted}{C++}
    int value1 = 5;
    const int *ptr = &value1;   // ptr points to a const int
    int value2 = 6;
    ptr = &value2;  // OK, ptr now points at some other const int
\end{minted}

总而言之，不允许非常量指针指向常量，也不允许通过常量指针来修改它所指向的内容。

函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容：
\begin{minted}{C++}
    void myPrintf(const char *p)
    {
        // error: no matching function for call to 'strcpy'
        // note: candidate function not viable: 1st argument ('const char *') would lose const qualifier
        // char    *strcpy(char *__dst, const char *__src);
        // strcpy(p, "this");
        cout << p << endl;
    }
\end{minted}

\subsubsection{定义指针常量}
我们也可以把某个指针本身定义为常量，称为指针常量。一个指针的值在初始化后就不能被改变，这个指针就称为指针常量。
\begin{minted}{C++}
    int value = 5;
    int *const ptr = &value;
\end{minted}

和普通的常量一样，指针常量在声明的时候就要进行初始化为某个值。这就意味着，指针常量总是指向相同的地址。
\begin{minted}{C++}
    int value1 = 5;
    int value2 = 6;
    // OK, the const pointer is initialized to the address of value1
    int *const ptr = &value1;
    // not OK, a const pointer can not be changed
    ptr = &value2;
\end{minted}

如果指针常量指向的是变量而不是常量，就可以通过指针常量来修改该变量的值。
\begin{minted}{C++}
    int value = 5;
    int *const ptr = &value;    // ptr will always point to value
    *ptr = 6;   // allowed, since ptr points to a non-const int
\end{minted}

可以同时声明一个指针既是常量指针也是指针常量。这时，既不能修改这个指针常量本身的值，也不能通过它修改它所指向的内容。
\begin{minted}{C++}
    int value = 5;
    const int *const ptr = &value;
\end{minted}

\subsubsection{定义常引用}
不能通过常引用修改其引用的变量：
\begin{minted}{C++}
    int n;
    const int &r = n;
    // r = 5;  // error: cannot assign to variable 'r' with const-qualified type 'const int &'
\end{minted}

注意：被引用的变量的值可以通过其他方式改变。

\subsection{动态内存分配}
\subsubsection{用 \mintinline{C++}{new} 运算符实现动态内存分配}
第一种用法，分配一个变量：
\begin{minted}{C++}
    P = new T;
\end{minted}

其中，\texttt{T} 是任意类型名，\texttt{P} 是类型为 \texttt{T *} 的指针。动态分配出一片大小为
\mintinline{C++}{sizeof(T)} 字节的内存空间，并且将该内存空间的起始地址赋值给 \texttt{P}。比如：
\begin{minted}{C++}
    int *pn;
    pn = new int;
    *pn = 5;
\end{minted}

第二种用法，分配一个数组：
\begin{minted}{C++}
    P = new T[N];
\end{minted}
其中，\texttt{T} 是任意类型名，\texttt{P} 是类型为 \texttt{T *} 的指针，\texttt{N} 为要分配的数组元素的个数，
可以是整型表达式。动态分配出一片大小为 \mintinline{C++}{N * sizeof(T)} 字节的内存空间，并且将该内存空间的起始地
址赋值给 \texttt{P}。

动态分配数组示例：
\begin{minted}{C++}
    int *pn;
    int i =5;
    pn = new int[i * 20];
    pn[0] = 20;
    pn[100] = 30;   // 编译没错，运行时有可能导致数组越界报错。gcc/g++ 不检查数组越界。
    return 0;
\end{minted}

\mintinline{C++}{new T} 和 \mintinline{C++}{new T[n]} 这两个表达式的返回值类型都是 \texttt{T *}。

\subsubsection{用 \mintinline{C++}{delete} 运算符释放动态分配的内存}

用 \mintinline{C++}{new} 动态分配的内存空间，一定要用 \mintinline{C++}{delete} 运算符进行释放：
\mint{C++}{delete pointer;  // pointer 必须指向 new 出来的空间}

一片动态分配的内存空间不能被 \mintinline{C++}{delete} 两次，否则运行时会报出异常。

用 \mintinline{C++}{delete} 释放动态分配的数组时，要加上 \texttt{[]}：
\mint{C++}{delete[] pointer;  // pointer 必须指向 new 出来的数组}

\subsection{内联函数、函数重载和函数缺省参数}
\subsubsection{内联函数}
函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开
销就会显得比较大。

为了减少哦函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而
不会产生调用函数的语句。

在函数定义前加 \mintinline{C++}{inline} 关键字，即可定义内联函数：
\begin{minted}{C++}
    inline int max(int a, int b)
    {
        if (a > b) {
            return a;
        }
        return b;
    }
\end{minted}

以上面的代码为例，\texttt{max} 函数本身就比较简单，如果它被反复多次执行的话，调用 \texttt{max} 函数的产生的额外开
销和 \texttt{max} 函数本身执行时的开销是相当的，所以可以将其定义为内联函数来减少调用它的时间开销。通过
\mintinline{C++}{inline} 声明，编译器首先在函数调用处使用函数本身语句替换了函数调用语句，然后编译替换后的代码，运
行时不需要跳转到内存其他地址去执行函数调用，也不需要保留函数调用时的现场数据。通过将函数声明为内联，可以将函数的定义放
在头文件内，在类内部定义的函数会默认声明为内联函数。

但是由于代码的扩展，内联函数可能会增大可执行程序的体积；如果内联函数发生了改动，需要重新编译代码。而内联声明只是对编译
器的一种建议，编译器会自己决定是否采用内联措施，这取决于函数是否符合内联的有利条件。如果函数体非常大，编译器将会忽略内
联声明，将内联函数作为普通函数来处理。

\subsubsection{函数重载}
一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。

以下三个函数是重载关系：
\begin{minted}{C++}
    int Max(double f1, double f2);
    int Max(int n1, int n2);
    int Max(int n1, int n2, int n3);
\end{minted}

函数重载使得函数命名变得简单。编译器根据调用语句中的实参个数和类型判断应该调用哪个函数，有时会出现二义性的错误。C 语言
里是没有函数重载的，函数命名不能相同。

\begin{minted}{C++}
    Max(3.4, 2.5);  // 调用 int Max(double f1, double f2)
    Max(2, 4);      // 调用 int Max(int n1, int n2)
    Max(1, 2, 3);   // 调用 int Max(int n1, int n2, int n3)
    Max(3, 2.4);    // error: call to 'Max' is ambiguous
\end{minted}

如果两个函数函数名和参数都一样，只是返回值不同，这时不能重载，编译时会报错:
\begin{minted}{C++}
    int Max(double f1, double f2) {}
    // error: functions that differ only in their returntype cannot be overloaded
    // double Max(double f1, double f2) {}
\end{minted}

\subsubsection{函数的缺省参数}
C++ 中，定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。

\begin{minted}{C++}
    void func(int x1, int x2 = 2, int x3 = 3) {}
    // error: missing default argument on parameter 'x2'
    // void func(int x1 = 1, int x2, int x3 = 3) {}
    // when call the function func
    func(10);       // OK, same as func(10, 2, 3);
    func(10, 8);    // OK, same as func(10, 8, 3);
    // func(10, , 8);  // error. 只能最右边的连续若干个参数缺省
\end{minted}

函数可缺省的目的在于提高程序的可扩充性。即如果某个写好的函数要添加新的参数，而原来那些调用该函数的语句，未必需要使用新
增的参数，那么为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。

\section{浅谈面向对象的程序设计}
\subsection{面向对象的基本概念}
结构化程序设计：
\begin{itemize}
    \item 复杂的大问题 $\rightarrow$ 层层分解/模块化 $\rightarrow$ 若干子问题
    \item 自顶向下，逐步求精
\end{itemize}

程序 = 数据结构（变量） + 算法（函数）

在结构化程序设计中，数据结构与算法没有直观的联系，会遇到四大问题：理解难、修改难、查错难、重用难。

软件设计的目标是更快、更正确、更经济，所以业界需要面向对象。

面向对象的程序设计方法继承了结构化程序设计的优点，同时又克服了结构化程序设计中的一些不足，它的设计思路更加接近于我们的
现实生活。

面向对象的程序 = 类 + 类 + ... + 类

面向对象的程序设计中的基本概念：
\begin{description}
    \item[抽象] 归纳出一类事物的共同属性（数据结构）和行为（函数）
    \item[封装] 将数据结构和算法对应地捆绑在一起
    \item[继承]
    \item[多态]
\end{description}

\subsection{面向对象的程序设计语言的发展历程}
早起程序设计语言的历史：
\begin{itemize}
    \item ALGOL 60: 1960 年
    \item CPL: 1963 年
    \item BCPL: 1967 年
    \item B: 1970 年
    \item C: 1973 年
\end{itemize}

面向对象的程序设计语言的历史：
\begin{itemize}
    \item Simula 67: 1967 年
    \item Smalltalk: 1971 年
    \item C++: 1983 年
    \item Java: 1995 年
    \item C\#: 2003 年
\end{itemize}

C++ 标准的发展：
\begin{itemize}
    \item C++2.0: 1989 年
    \item ANSI C++: 1994 年
    \item C++98: 1998 年，加入 STL（Standard Template Library）泛型设计
    \item C++03: 2003 年
    \item \emph{Libraray Technical Report 1}(TR1): 2005 年
    \item C++11: 2011 年
\end{itemize}

常用的 C++ 编译器
\begin{itemize}
    \item GCC
    \item Visual C++
    \item Dev C++
    \item Eclipse
    \item Borland C++Builder
\end{itemize}

\section{类和对象}
\subsection{类的定义}
类包含成员变量和成员函数，二者统称为类的成员。可以将类看作是带有函数的结构体。

类的定义：
\begin{minted}{C++}
    class 类名 {
        访问范围说明符：
            成员变量1
            成员变量2
            ...
            成员函数声明1
            成员函数声明2
        访问范围说明符：
            更多成员变量
            更多成员函数声明
            ...
    };
\end{minted}

以抽象出的矩形类 \texttt{CRectangle} 为例：
\begin{minted}{C++}
    class CRectangle {
        public:
            int w;
            int h;
            void Init(int w_, int h_) {
                w = w_;
                h = h_;
            }
            int Area() {
                return w * h;
            }
            int Perimeter() {
                return 2 * (w + h);
            }
    };  // 必须有分号
\end{minted}

在程序中使用类来创建对象：
\begin{minted}{C++}
    int main() {
        int w, h;
        CRectangle r;   // r 是一个对象
        cin >> w >> h;
        r.Init(w, h);
        cout << r.Area() << endl << r.Perimeter() << endl;
        return 0;
    }
\end{minted}

类定义的变量 $\rightarrow$ 类的实例 $\rightarrow$ “对象”

每个对象都有自己的存储空间，对象的大小是所有成员变量的大小之和。一个对象的某个成员变量被改变，不会影响到其他的对象。

对象之间可以用 “=” 进行赋值，不能使用“==”、“!=”、“>”、“<”等进行比较，除非这些运算符经过了重载。

\subsection{访问类的成员变量和成员函数}
\subsubsection{访问类的成员变量和成员函数的三种常用方式}
用法1：对象名.成员名
\begin{minted}{C++}
    CRectangle r1, r2;
    r1.w = 5;
    r2.Init(3, 4);
\end{minted}

用法2：指针->成员名
\begin{minted}{C++}
    CRectangle r1, r2;
    CRectangle *p1 = &r1;
    CRectangle *p2 = &r2;
    p1->w = 5;
    p2->Init(3, 4);
\end{minted}

用法3：引用名.成员名
\begin{minted}{C++}
    CRectangle r2;
    CRectangle &rr = r2;
    rr.w = 5;
    rr.Init(3, 4);  // rr 的值变了，r2 的值也变了
\end{minted}

另一种输出结果的方式：
\begin{minted}{C++}
    void printRectangle(CRectangle &r) {
        cout << r.Area() << ", " << r.Perimeter();
    }
    CRectangle r3;
    r3.Init(3, 4);
    printRectangle(r3);
\end{minted}

成员函数体和类的定义可以分开写：
\begin{minted}{C++}
    // CRectangle.h
    class CRectangle {
        public:
            int w, h;
            int Area();
            int Perimeter();
            void Init(int w_, int h_);
    };

    // CRectangle.cpp
    int CRectangle::Area() {
        return w * h;
    }
    int CRectangle::Perimeter() {
        return 2 * (w + h);
    }
    void CRectangle::Init(int w_, int h_) {
        w = w_;
        h = h_;
    }
\end{minted}

\subsubsection{类成员的可访问范围}
类成员的可访问范围由以下三种关键字确定：
\begin{itemize}
    \item \mintinline{C++}{private}: 指定私有成员，只能在成员函数内被访问
    \item \mintinline{C++}{public}: 指定公有成员，可以在任何地方被访问
    \item \mintinline{C++}{protected}: 指定保护成员（后面讲“继承”时会讲到）
\end{itemize}

三种关键字出现的次数和先后次序都没有限制。如果没有指定，默认为私有成员（\mintinline{C++}{private}）。
\begin{minted}{C++}
    class Man {
            int nAge;           // private
            char szName[20];    // private
        public:
            void SetName(char *name) {
                strcpy(szName, name);   // OK
            }
    }
\end{minted}

类的成员函数内部，可以访问：
\begin{itemize}
    \item 当前对象的全部属性、函数
    \item 同类其它对象的全部属性、函数
\end{itemize}

类的成员函数以外的地方：
\begin{itemize}
    \item 只能访问该类对象的公有成员
\end{itemize}

设置私有成员的目的是强制对成员变量的访问一定要通过成员函数进行，从而有效地将私有成员隐藏起来。

\subsection{内联成员函数和重载成员函数}
\subsubsection{内联成员函数}
前面已经学到了内联函数。它是指一类特殊的函数，其自身的语句非常的少，运行起来也非常快，在这种情况下，由于函数调用会
产生一定的调用语句，那么当函数需要被反复调用时，就会产生非常大的调用开销。如果将其定义为内联函数，编译器会将此函数的定
义插入到调用的地方，就不会产生额外的调用开销了。成员函数也可以被定义为内联函数，称为内联成员函数。

定义内联成员函数的两种方式：
\begin{itemize}
    \item \mintinline{C++}{inline} + 成员函数
    \item 整个函数体出现在类定义内部
\end{itemize}

\begin{minted}{C++}
    class A {
        inline void func1();
        void func2() {
            // definition
        }
    };

    void A::func1() {}
\end{minted}

\subsubsection{重载成员函数}
类的成员函数也可以重载、带缺省参数。

两个重载函数的返回类型可以不一样，如 \mintinline{C++}|int func(int x) {}| 和
\mintinline{C++}|void func(){}| 是重载关系。但是如果两个函数仅在返回类型上有区别，那就会报重复定义的错误。

缺省参数既可以在函数声明时定义，也可以在函数实现时定义，但二者不能同时定义。

\begin{minted}{C++}
    class Location {
    private:
        int x;
        int y;
    public:
         void init(int x = 0, int y = 0);   // 可以在声明或实现时定义默认参数，但不能二者同时定义
         void value_x(int val) {x = val;}
         int value_x() {return x;}          // 重载函数返回类型可以不一样
    };

    void Location::init(int X, int Y) {
        x = X;
        y = Y;
    }

    int main(int argc, char const *argv[]) {
        Location A;
        A.init(5);
        A.value_x(5);
        cout << A.value_x() << endl;
        A.value_x();
        cout << A.value_x() << endl;
        return 0;
    }
\end{minted}

\subsection{构造函数}
\subsubsection{构造函数的基本概念}
构造函数是成员函数的一种，名字与类名相同，可以有参数，但不能有返回值（\texttt{void} 也不行）。构造函数的作用是对对象
进行初始化，如给成员变量赋初值。

如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数，不做任何操作。如果定义了构造函数，则编译器不生成默认
的无参构造函数。一个类可以定义多个构造函数。对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数。

为什么需要构造函数：
\begin{enumerate}
    \item 构造函数执行必要的初始化工作，有了构造函数就不用专门再写初始化函数，也不用担心忘记调用初始化函数。
    \item 有时对象没被初始化就使用，会导致程序出错。
\end{enumerate}

例如，定义了一个类 \mintinline{C++}{Complex}，但没有定义构造函数。在生成对象时，会调用默认的构造函数：
\begin{minted}{C++}
    class Complex {
    private:
        double real, imag;
    public:
        void set(double r, double i);
    };  // 编译器自动生成默认构造函数

    int main(int argc, char const *argv[]) {
        Complex c1;                 // 默认构造函数被调用
        Complex *pc = new Complex;  // 默认构造函数被调用
        return 0;
    }
\end{minted}

如果定义了构造函数，编译器就不会生成默认的无参构造函数了：
\begin{minted}{C++}
    class Complex {
    private:
        double real, imag;
    public:
        Complex(double r, double i = 0);    // 构造函数也需要声明
        void set(double r, double i);
    };

    Complex::Complex(double r, double i) {
        real = r;
        imag = i;
    }


    int main(int argc, char const *argv[]) {
        // error: no matching constructor for initialization of 'Complex'
        // Complex c1;
        // error: no matching constructor for initialization of 'Complex'
        // Complex *pc = new Complex;
        Complex c1(2);                      // OK
        Complex c2(2, 4), c3(3, 5);         // OK
        Complex *pc = new Complex(3, 4);    // OK
        return 0;
    }
\end{minted}

一个类可以有多个构造函数，多个构造函数之间是重载的关系。

构造函数最好是 \mintinline{C++}{public} 的，\mintinline{C++}{private} 构造函数不能直接用来初始化对象。

\subsubsection{构造函数在数组中的使用}
\begin{minted}{C++}
    class CSample {
    private:
        int x;
    public:
        CSample() {
            cout << "CSample constructor 1 is called." << endl;
        }
        CSample(int n) {
            x = n;
            cout << "CSample constructor 2 is called." << endl;
        }
    };

    class Test {
    public:
        Test(int n) {
            cout << "Test constructor 1 is called." << endl;
        }
        Test(int n, int m) {
            cout << "Test constructor 2 is called." << endl;
        }
        Test() {
            cout << "Test constructor 3 is called." << endl;
        }
    };

    int main(int argc, char const *argv[]) {
        CSample array1[2];  // 对象数组
        // CSample constructor 1 is called.
        // CSample constructor 1 is called.
        cout << "step 1" << endl;
        CSample array2[2] = {4, 5}; // 等同于 CSample array2[2] = {CSample(4), CSample(5)};
        // CSample constructor 2 is called.
        // CSample constructor 2 is called.
        cout << "step 2" << endl;
        CSample array3[2] = {3};
        // CSample constructor 2 is called.
        // CSample constructor 1 is called.
        cout << "step 3" << endl;
        CSample *array4 = new CSample[2];
        // CSample constructor 1 is called.
        // CSample constructor 1 is called;
        delete[] array4;

        Test testArray1[3] = {1, Test(1, 2)};
        // Test constructor 1 is called
        // Test constructor 2 is called
        // Test constructor 3 is called
        Test testArray2[3] = {Test(2, 3), Test(1, 2), 1};
        // Test constructor 2 is called
        // Test constructor 2 is called
        // Test constructor 1 is called
        Test *pArray[3] = {new Test(4), new Test(1, 2)}; // pArray[3] 是指针数组，不是对象数组
        // Test constructor 1 is called
        // Test constructor 2 is called
        // pArray[2] 是一个未初始化的指针
        return 0;
    }
\end{minted}

\subsubsection{复制（拷贝）构造函数}
复制构造函数只有一个参数，即对同类对象的引用。形如 \mintinline{C++}{X::X(X &)} 或
\mintinline{C++}{X::X(const X &)} 二者中的一种，后者能以常量对象作为参数。

如果没有定义复制构造函数，那么编译器会生成默认的复制构造函数。
\begin{minted}{C++}
    class Complex {
    private:
        double real;
        double imag;
    };

    int main(int argc, char const *argv[]) {
        Complex c1;     // 调用缺省无参构造函数
        Complex c2(c1); // 调用缺省的复制构造函数，将 c2 初始化成和 c1 一样
        return 0;
    }
\end{minted}

如果定义自己的复制构造函数，那么默认的复制构造函数将不存在，因为复制构造函数只能有一个。
\begin{minted}{C++}
    class Complex {
    private:
        double real;
        double imag;
    public:
        Complex() {}    // 复制构造函数也是构造函数，一旦定义了，默认的无参构造函数会消失
        Complex(const Complex &c) {
            real = c.real;
            imag = c.imag;
            cout << "Complex copy constructor is called." << endl;
        }
    };

    int main(int argc, char const *argv[]) {
        Complex c1;     // 调用自定义无参构造函数
        Complex c2(c1); // 调用自定义的复制构造函数
        // Complex copy constructor is called.
        return 0;
    }
\end{minted}

不允许有形如 \mintinline{C++}{X::X(X)} 的复制构造函数，它的参数应该是引用，而不是对象:
\begin{minted}{C++}
    class CSample {
        CSample(CSample c) {
        }   // 错误，不允许这样的构造函数
    };
\end{minted}

复制构造函数起作用的三种情况：
\begin{enumerate}
    \item 当用一个对象去初始化同类的另一个对象时。
    \begin{minted}{C++}
    Complex c2(c1);
    Complex c2 = c1;    // 同上，初始化语句，非赋值语句
    \end{minted}
    \item 如果函数有一个参数是类 A 的对象，那么该函数被调用时，类 A 的复制构造函数将被调用。
    \begin{minted}{C++}
    class A {
    public:
        A() {};
        A(A &a) {
            cout << "A copy constructor is called." << endl;
        }
    };
    void Func1(A a1) {}
    int main() {
        A a2;
        Func1(a2);   // 由于是自定义复制构造函数，实参 a2 和形参 a1 不一定相等
        // A copy constructor is called.
        return 0;
    }
    \end{minted}
    \item 如果函数的返回值是类 A 的对象时，则函数返回时，A 的复制构造函数被调用。
    \begin{minted}{C++}
    class B {
    public:
        int v;
        B(int n) {v = n;}
        B(const B &a) {
            v = 5;
            cout << "B copy constructor is called." << endl;
        }
    };

    B Func2() {
        B b(4);
        return b;
    }

    int main(int argc, char const *argv[]) {
        cout << Func2().v << endl;
        // B copy constructor is called.
        // 5
        return 0;
    }
    \end{minted}
    注意：某些编译器如 G++ 会针对返回值进行优化，导致返回对象时不会调用复制构造函数，编译时可以加上
    \mintinline{C++}{-fno-elide-constructors} 参数来关闭这项优化。
    \footnote{《C++返回值为对象时复制构造函数不执行怎么破》https://www.kancloud.cn/digest/bugkiller/163413}
\end{enumerate}

\subsubsection{类型转换构造函数}
对于一个类 \texttt{X} 来说，当它的某个构造函数只有一个参数，且该参数又不是 \mintinline{C++}{const X &} 类型时，
这个构造函数就称为类型转换构造函数。

类型转换构造函数的目的是将一个其他类型的数据转换成一个类的对象。类型转换构造函数只有一个参数(C++11 之前)，不是复制构造
函数。

\begin{minted}{C++}
    class Complex {
    public:
        double real, imag;
        Complex(int i) {    // 类型转换构造函数
            cout << "Int constructor of Complex is called." << endl;
            real = i;
            imag = 0;
        }
        Complex(double r, double i) {
            cout << "Constructor of Complex is called." << endl;
            real = r;
            imag = i;
        }
    };

    int main(int argc, char const *argv[]) {
        Complex c1(7, 8);
        // Constructor of Complex is called.
        Complex c2 = 12;    // 注意这里的 = 是初始化，不是赋值
        // Int constructor of Complex is called.
        c1 = 9; // OK. 9 被自动转换成一个临时的 Complex 对象，然后赋值给 c1
        // Int constructor of Complex is called.
        return 0;
    }
\end{minted}

\subsection{析构函数}
\subsubsection{析构函数的定义}
析构函数也是成员函数的一种，负责处理消亡的对象。在对象消亡时，析构函数会自动被调用，做一些如释放分配的内存空间等善后工
作。

析构函数的函数名与类名相同，不过函数名前面有个 $\sim$，没有参数和返回值。一个类最多有一个析构函数。

定义类时如果没有写析构函数，编译器会生成缺省析构函数。缺省析构函数不涉及释放用户申请的内存释放等清理工作。如果定义了析
构函数，则编译器不生成缺省析构函数。

\begin{minted}{C++}
    class String {
    private:
        char *p;
    public:
        String() {
            p = new char[10];
        }
        ~String();
    };

    String::~String() {
        delete[] p;
    }
\end{minted}

\subsubsection{析构函数和数组}
当对象数组的生命周期结束时，对象数组的每个元素都会调用到析构函数。
\begin{minted}{C++}
    class Ctest {
    public:
        ~Ctest() {
            cout << "Destructor of Ctest is called" << endl;
        }
    };

    int main(int argc, char const *argv[]) {
        Ctest array[2];
        cout << "End main" << endl;
        // End main
        // Destructor of Ctest is called
        // Destructor of Ctest is called
        return 0;
    }
\end{minted}

\subsubsection{析构函数和运算符 \mintinline{C++}{delete}}
用 \mintinline{C++}{new} 运算新建对象会调用构造函数，类似地，用 \mintinline{C++}{delete} 运算释放对象会调用析
构函数。
\begin{minted}{C++}
    Ctest *pTest;
    pTest = new Ctest;  // 构造函数调用
    delete pTest;       // 析构函数调用
    // Destructor of Ctest is called
\end{minted}

但是，如果用 \mintinline{C++}{new} 新建的对象只能用 \mintinline{C++}{delete} 释放，不会自动调用析构函数。
\begin{minted}{C++}
    class A {
    public:
        A() {
            cout << "Constructor of A is called." << endl;
        }
        ~A() {
            cout << "Destructor of A is called." << endl;
        }
    };

    int main(int argc, char const *argv[]) {
        A *p = new A[2];
        // Constructor of A is called.
        // Constructor of A is called.
        A *p2 = new A;  // 用 new 创建的对象不会自动释放，不会调用析构函数
        // Constructor of A is called.
        A a;
        // Constructor of A is called.
        delete[] p;
        // Destructor of A is called.
        // Destructor of A is called.
        // Destructor of A is called.
        return 0;
    }
\end{minted}

\subsection{静态成员变量和静态成员函数}
静态成员：在声明前面加了 \mintinline{C++}{static} 关键字的成员。
\begin{minted}{C++}
    class CRectangle {
    private:
        int w, h;
        static int nTotalArea;      // declare static member variable nTotalArea
        static int nTotalNumber;    // declare static member variable nTotalNumber
    public:
        CRectangle(int w_, int h_);
        ~CRectangle();
        static void PrintTotal();   // declare static member function PrintTotal()
    };
\end{minted}

静态成员属于整个类，不属于某些特定的对象。

普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。\mintinline{C++}{sizeof} 运算符计算一
个对象所占的内存空间时，不会计算静态成员变量。也就是说，静态成员变量其实不是存储在对象内部的。

普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象，不需要通过对象就能访问。

访问静态成员的方式（前提是有访问权限）：
\begin{enumerate}
    \item \mintinline{C++}{类名::成员名}（首选方式）
    \begin{minted}{C++}
    CRectangle::PrintTotal();
    \end{minted}
    \item \mintinline{C++}{对象名.成员名}
    \begin{minted}{C++}
    CRectangle r;
    r.PrintTotal();
    \end{minted}
    \item \mintinline{C++}{指针->成员名}
    \begin{minted}{C++}
    CRectangle *p = &r;
    p->PrintTotal();
    \end{minted}
    \item \mintinline{C++}{引用.成员名}
    \begin{minted}{C++}
    CRectangle &ref = r;
    int n = ref.nTotalNumber;
    \end{minted}
\end{enumerate}

静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。静态成员函数本质上是全局函数。

设置静态成员的这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。

类里面涉及静态成员变量的语句仅仅是对静态成员变量的声明，不是定义。在使用静态成员变量的时候，需要在所有函数外面对静态成
员变量进行定义，而且不管有没有访问权限，都可以选择是否对其进行初始化。
\begin{minted}{C++}
    // 定义静态变量，并初始化为0
    int CRectangle::nTotalNumber = 0;
    int CRectangle::nTotalArea = 0;
\end{minted}

为什么要这样设计呢？为什么不在类内定义它呢？这是由于遵循了每个要使用的静态对象都要定义且仅定义一次的原则。类的定
义一般都会放在头文件（\texttt{.h}）里，但是静态变量的使用一般在源程序文件（\texttt{.cpp}）里，要使用就要在源程序文
件内对其定义。而如果定义类的时候也定义静态变量，这就有可能导致多次定义的错误。
\footnote{Why does a static data member need to be defined outside of the class?
https://stackoverflow.com/questions/18749071/why-does-a-static-data-member-need-to-be-defined-outside-of-the-class}

在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。这是因为静态成员函数不是作用在某个特定的对象上的，
非静态成员变量属于特定的对象。但是反过来，在非静态成员函数中是可以调用静态成员函数的。

\subsection{成员对象、封闭类和成员初始化列表}
\subsubsection{成员对象和封闭类的定义}
成员对象：一个类的成员变量是另一个类的对象，这种成员变量就称为成员对象。

封闭类：包含成员对象的类。
\begin{minted}{C++}
    class CTyre {
    private:
        int radius;
        int width;
    public:
        // Member initializer lists. radius = r; width = w;
        CTyre(int r, int w) : radius(r), width(w) {}
    };

    class CEngine {
    };

    class CCar {    // enclosing class
    private:
        int price;
        CTyre tyre;
        CEngine engine;
    public:
        CCar(int p, int tr, int tw);
    };
\end{minted}

\subsubsection{成员初始化列表}
前面 \mintinline{C++}|CTyre(int r, int w):radius(r), width(w) {}| 中用到了成员初始化列表。在介绍成员初始
化列表之前，先补充一下 C++ 中的三种初始化变量的方式（注意是初始化，不是赋值）：
\begin{enumerate}
    \item 复制初始化
    \begin{minted}{C++}
    int nValue = 5; // copy initialization
    \end{minted}
    \item 直接初始化
    \begin{minted}{C++}
    int nValue(5);  // direct initialization
    \end{minted}
    \item 统一初始化（C++11）
    \begin{minted}{C++}
    int nValue{5};  // uniform initialization or brace initialization (C++11)
    \end{minted}
\end{enumerate}

之前我们在写构造函数的时候，是利用赋值运算符通过赋值的方式进行的复制初始化。这不是推荐的方式，有些时候会比较低效。而且
对于某些数据类型，例如 \mintinline{C++}{const} 和引用，必须在声明的时候就要初始化：
\begin{minted}{C++}
    class Something {
    private:
        const int m_value;
    public:
        Something() {
            // error: constructor for 'Something' must explicitly initialize the const member
            m_value = 1;
        }
    };

    const int m_value; // error: const vars must be initialized with a value
    m_value = 5; //  error: const vars can not be assigned to
\end{minted}

而我们有些时候并不想在声明类的成员常量时就指定一个值，而是想在创建对象并初始化的时候再指定。

如果在前面的封闭类 \texttt{CCar} 中不定义构造函数，让编译器使用默认的构造函数。创建对象 \texttt{car} 并初始化时，
对于成员对象 \texttt{car.engine}，编译器可以使用默认构造函数初始化，对于没有默认构造函数的成员对象
\texttt{car.tyre} 就不知道该如何初始化了，所以就会报错。

成员初始化列表可以解决上面的这些问题。

定义构造函数时，添加成员初始化列表：
\begin{minted}{C++}
    类名::构造函数(参数表) : 成员变量1(参数表), 成员变量2(参数表), ... // 直接初始化成员变量
    {
        // 不需要在这里写赋值语句
    }
\end{minted}

成员对象初始化列表中的参数：
\begin{itemize}
    \item 任意复杂的表达式
    \item 函数/变量/表达式中的函数，变量必须有定义
\end{itemize}

利用成员初始化列表来初始化成员常量：
\begin{minted}{C++}
    class Something {
    private:
        const int m_value;

    public:
        Something(): m_value(5) {} // directly initialize our const member variable
    };
\end{minted}

\subsubsection{封闭类的调用顺序}
封闭类的对象遵循“先构造的后析构”的顺序。

当封闭类对象生成时：
\begin{enumerate}
    \item 执行所有成员对象的构造函数
    \item 执行封闭类的构造函数
\end{enumerate}

当封闭类的对象消亡时：
\begin{enumerate}
    \item 执行封闭类的析构函数
    \item 执行成员对象的析构函数
\end{enumerate}

成员对象的构造函数调用顺序与成员对象在类中的声明一致，与其在成员初始化列表中出现的顺序无关。

\subsection{友元}
\subsubsection{友元函数}
一个类的友元函数可以访问该类的私有成员。除此之外，友元函数和其他函数并无差别。友元函数可以是某个普通函数，也可以是某个
类的成员函数。声明类的成员函数为友元函数时，要在该函数前加上类名和\mintinline{C++}{::}。

在一个类中，如果想把哪个函数定义为友元函数，直接写下它的函数原型，并在前面加上一个 \mintinline{C++}{friend} 关键字
就可以了，在私有范围还是公有范围都不影响。
\begin{minted}{C++}
    class Accumulator {
    private:
        int m_value;
    public:
        Accumulator() { m_value = 0; }
        void add(int value) { m_value += value; }

        // Make the reset() function a friend of this class
        friend void reset(Accumulator &accumulator);
    };

    // reset() is now a friend of the Accumulator class
    void reset(Accumulator &accumulator) {
        // And can access the private data of Accumulator objects
        accumulator.m_value = 0;
    }

    int main() {
        Accumulator acc;
        acc.add(5); // add 5 to the accumulator
        reset(acc); // reset the accumulator to 0
        return 0;
    }
\end{minted}

要注意的是，我们必须要把特定的对象传递给友元函数，这样友元函数才能操作其私有成员变量。友元函数无法访问相应类的对象的
\mintinline{C++}{*this} 指针。一个函数可以同时作为多个类的友元函数。

\subsubsection{友元类}
可以将一个类声明为另一个类的友元，称为友元类。

A 是 B 的友元类 $\Rightarrow$ A 的成员函数可以访问 B 的私有成员

\begin{minted}{C++}
    class CDriver;  // 前置声明

    class CCar {
    private:
        int price;
        friend class CDriver;   // 声明 CDriver 为友元类
    };

    class CDriver {
    public:
        CCar myCar;
        void ModifyCar() {
            // CDriver 是 CCar 的友元类，可以访问其私有成员
            myCar.price += 1000;
        }
    };
\end{minted}

需要注意，对于一个类来说，其友元类虽然可以访问它的对象的私有成员，但是无法访问它的对象的 \mintinline{C++}{*this}
指针。A 是 B 的友元类，并不意味着 B 也是 A 的友元类。友元类之间的关系不能传递，不能继承。

一个类的友元函数和友元类破坏了它的封装性。如果这个类的某些细节需要改动，那友元也要跟着做出相应的改动。因此，要尽可能地
限制使用友元函数和友元类。

\subsection{\mintinline{C++}{this} 指针}
C++ 语言刚诞生的时候是没有能直接将 C++ 语言编译成机器语言的编译器的，而是先翻译成 C 语言，然后再通过 C 的编译器将其
编译成机器语言。C++ 语言编译成 C 语言，对象对应结构体，之后就会多一个 \mintinline{C++}{this} 指针。尽管现在已经有
了 C++ 的直接编译器了，但是依然可以这么理解，即会多出一个 \mintinline{C++}{this} 指针，其作用是指向成员函数所作用
的对象。

C++ 代码：
\begin{minted}{C++}
    class CCar {
    public:
        int price;
        void SetPrice(int p);
    };
    void CCar::SetPrice(int p) {
        price = p;
    }
    int main() {
        CCar car;
        car.SetPrice(20000);
        return 0;
    }
\end{minted}

翻译后的 C 代码：
\begin{minted}{C}
    struct CCar {
        int price;
    };
    void SetPrice(struct CCar *this, int p) {
        this->price = p;
    }
    int main() {
        struct CCar car;
        SetPrice(&car, 20000);
        return 0;
    }
\end{minted}

非静态成员函数中可以直接使用 \mintinline{C++}{this} 来代表指向该函数作用的对象的指针。
\begin{minted}{C++}
    class Complex {
    public:
        double real, imag;
        void Print() {
            std::cout << real << "," << imag << std::endl;
        }
        Complex(double r, double i) : real(r), imag(i) {}
        Complex AddOne() {
            this->real++;
            this->Print();
            return *this;
        }
    };

    int main(int argc, char const *argv[]) {
        Complex c1(1, 1), c2(0, 0);
        c2 = c1.AddOne();   // 2,1
        return 0;
    }
\end{minted}

比较下面代码中 A、B 类的不同，体会 \mintinline{C++}{this} 指针的作用。
\begin{minted}{C++}
    class A {
    private:
        int i;
    public:
        void Hello() {
            std::cout << "Hello world!" << std::endl;
        }
    };

    class B {
    private:
        int i;
    public:
        void Hello() {
            std::cout << i << " Hello world!" << std::endl;
        }
    };

    int main(int argc, char const *argv[]) {
        A *p1 = NULL;
        p1->Hello();    // Hello world!
        B *p2 = NULL;
        p2->Hello();    // Segmentation fault: 11
        return 0;
    }
\end{minted}

\mintinline{C++}{this} 指针并不占用对象的内存空间，不会影响 \mintinline{C++}{sizeof} 运算符的结果。它与对象并
不存在包含关系，只是当对象调用函数时，对象被 \mintinline{C++}{this} 指针指向。\mintinline{C++}{this} 指针的存
放位置跟编译器有关，可能是栈，也可能是寄存器，甚至是全局变量。

静态成员函数并不具体作用于某个对象，因此静态成员函数中不能使用 \mintinline{C++}{this} 指针。普通成员函数的真实参数
个数要比参数表中写的多一个 \mintinline{C++}{this} 指针，而静态成员函数的真实的参数个数就是程序中写出的参数个数。

\subsection{常量对象、常量成员函数和常引用}
\subsubsection{常量对象}
如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加上 \mintinline{C++}{const} 关键字。
\begin{minted}{C++}
    class Demo {
    private:
        int value;
    public:
        Demo(int v) : value(v) {}
        void setValue(int v) {
            value = v;
        }
    };

    int main(int argc, char const *argv[]) {
        const Demo obj(0); // const object

        // error: member function 'setValue' not viable: 'this' argument has type
        // 'const Demo', but function is not marked const
        obj.setValue(1);
        return 0;
    }
\end{minted}

常量对象一旦通过构造函数完成了初始化，它的成员变量就不允许通过任何方式修改，不管是直接修改还是通过成员函数修改都不行。
常量对象只可以调用其常量成员函数。

\subsubsection{常量成员函数}
在类的成员函数声明后面可以加 \mintinline{C++}{const} 关键字，则该成员函数成为常量成员函数。如果该常量成员函数需要
在类外定义，则类内的声明后面和类外的定义后面都要加 \mintinline{C++}{const} 关键字。

常量成员函数执行期间不应该修改其作用的对象。因此，在常量成员函数中可以访问但不能修改成员变量的值（静态成员变量除外），
也不能调用同类的非常量成员函数（静态函数成员除外）。

\begin{minted}{C++}
    class Sample {
    public:
        int value;
        Sample() {}
        void getValue() const;
        void func() {}
    };

    void Sample::getValue() const {
        // error: cannot assign to non-static data member within const member
        // function 'getValue'
        value = 0;
        // error: member function 'func' not viable: 'this' argument has type
        // 'const Sample', but function is not marked const
        func();
    }

    int main() {
        const Sample o; // 大部分编译器需要为 Sample 类编写构造函数，然后才能
        // error: cannot assign to variable 'o' with const-qualified type
        // 'const Sample'
        o.value = 100;
        // error: member function 'func' not viable: 'this' argument has type
        // 'const Sample', but function is not marked const
        o.func();
        o.getValue();   // OK
        return 0;
    }
\end{minted}

两个成员函数，名字和参数表都一样，但是一个是 \mintinline{C++}{const}，一个不是，它们是重载的关系，不是重复定义。

\subsubsection{常引用}
引用前面可以加 \mintinline{C++}{const} 关键字，成为常引用。不能通过常引用修改其引用的变量。
\begin{minted}{C++}
    class Sample {
        ...
    };
    void printfObj(const Sample &o) {
        ...
    }
\end{minted}

\section{运算符重载}
\subsection{运算符重载的基本概念}
C++ 中预定义的运算符如 \texttt{+}、\texttt{-}、\texttt{*}、\texttt{/} 等，只能用于如整型、实型、字符型、逻辑型
等基本的数据类型的运算。

C++ 提供了数据抽象的手段，允许用户通过类自定义数据类型，然后通过调用类的成员函数来操作它的对象。使用类的成员函数来操作
对象很不方便，我们希望像数学上一样，使用运算符来操作不同的对象，这时就可以对运算符进行重载。

运算符重载是指对已有的运算符赋予多重的含义，使同一运算符作用于不同类型的数据时产生不同的行为。运算符重载的实质是函数重
载。
\begin{minted}{C++}
    返回值类型 operator 运算符(形参表)
    {
        ...
    }
\end{minted}

运算符重载的目的是扩展 C++ 中提供的运算符的适用范围，以用于类所表示的抽象数据类型。运算符重载使得抽象数据类型也能够直
接使用 C++ 提供的运算符，使程序更简洁、代码更容易理解。

在程序编译时：
\begin{itemize}
    \item 把含运算符的表达式 $\rightarrow$ 对运算符函数的调用
    \item 把操作符的操作数 $\rightarrow$ 运算符函数的参数
    \item 运算符被多次重载时，根据实参的类型决定调用哪个运算符函数
    \item 运算符可以被重载为普通函数，也可以被重载为成员函数
\end{itemize}

\subsubsection{运算符被重载为普通函数}
\begin{minted}{C++}
    class ComplexN {
    public:
        ComplexN(double r = 0.0, double i = 0.0) {
            real = r;
            imaginary = i;
        }
        double real;
        double imaginary;
    };

    ComplexN operator+(const ComplexN &a, const ComplexN &b) {
        return ComplexN(a.real + b.real, a.imaginary + b.imaginary);
    }
    int main(int argc, char const *argv[]) {
        ComplexN a(1, 2), b(2, 3), c;
        c = a + b;
        return 0;
    }
\end{minted}

运算符被重载为普通函数时，参数个数为运算符目数。

\subsubsection{运算符被重载为成员函数}
\begin{minted}{C++}
    class ComplexM {
    public:
        ComplexM(double r = 0.0, double m = 0.0) : real(r), imaginary(m) {}
        ComplexM operator+(const ComplexM &);
        ComplexM operator-(const ComplexM &);
    private:
        double real;
        double imaginary;
    };

    ComplexM ComplexM::operator+(const ComplexM &operand) {
        return ComplexM(real + operand.real, imaginary + operand.imaginary);
    }

    ComplexM ComplexM::operator-(const ComplexM & operand) {
        return ComplexM(real - operand.real, imaginary - operand.imaginary);
    }

    int main(int argc, char const *argv[]) {
        ComplexM x, y(4.3, 8.2), z(3.3, 1.1);
        x = y + z;  // same as x = y.operator+(z);
        x = y - z;  // same as x = y.operator-(z);
        return 0;
    }
\end{minted}

运算符被重载为成员函数时，参数个数为运算符目数减一。

\subsection{赋值运算符的重载}
如果赋值运算符 \texttt{=} 两边的类型不匹配，我们就需要重载赋值运算符 \texttt{=} 。赋值运算符 \texttt{=} 只能重载
为成员函数，不能重载为普通函数。

\subsubsection{赋值运算符重载实例}
下面的代码编写了一个长度可变的字符串类 \texttt{MyString}，其成员包含一个 \mintinline{C++}{char *} 类型的成员变量，
指向动态分配的存储空间，该存储空间用于存放 \mintinline{C++}{'\0'} 结尾的字符串。

\begin{minted}{C++}
    class MyString {
    private:
        char *str;
    public:
        MyString() : str(NULL) {}
        const char *c_str() {return str;}
        char *operator=(const char *s);
        ~MyString();
    };

    char *MyString::operator=(const char *s) {
        if (str) delete[] str;
        if (s) {    // s is not NULL
            str = new char[strlen(s) + 1];  // + 1 for '\0'
            strcpy(str, s);
        } else {
            str = NULL;
        }
        return str;
    }

    MyString::~MyString() {
        if (str) delete[] str;
    }

    int main() {
        // no constructor MyString(char *)
        // error: no viable conversion from 'const char [11]' to 'MyString'
        // MyString s = "Good luck!";
        MyString s;
        s = "Good luck!";   // same as s.operator=("Good luck!");
        std::cout << s.c_str() << std::endl;    // Good luck!
        s = "Ocean University of China";
        std::cout << s.c_str() << std::endl;    // Ocean University of China

        MyString s1, s2;
        s1 = "this";
        s2 = "that";
        // Note: here won't call char *operator=(const char *s); the types don't match!
        // So it will call the default operator= by the compiler, use shallow copy
        s1 = s2;    // runtime error:  pointer being freed was not allocated
    }
\end{minted}

\subsubsection{重载赋值运算符的意义——浅拷贝和深拷贝}
C++ 并不了解我们自定义的类，它会为我们的类自动重载赋值运算符，采用的是方式是浅拷贝（shallow copy,
field-by-field copy or memberwise copy），这种赋值运算符的原型如下，它接受并返回一个指向类对象的引用：
\begin{minted}{C++}
ClassName &ClassName::operator=(const ClassName &);
\end{minted}

C++ 默认的复制构造函数和默认重载的赋值运算符都执行是浅拷贝。

对一个对象的浅拷贝会拷贝所有它所有成员的值。例如，如果该对象有一个 \mintinline{C++}{int} 类型的成员，那么就把
\mintinline{C++}{int} 类型的值拷贝过来。但是，如果该对象包含一个指针类型的成员，该指针指向一块动态申请的内存，这时
就会出现问题了。因为浅拷贝只会把这个指针成员拷贝一份，保证两个指针的值一样，但不会拷贝该指针所指向的内存空间。因此，如
果一个对象的成员里包含指针，浅拷贝之后，两个对象的指针成员会指向同一块内存。

而对一个对象进行深拷贝则不同，它会将该对象中指针成员指向的内容也复制一份到另一个对象指针成员指向的地方。深拷贝后，两个
对象的指针成员分别指向两块不同的内存空间，但这两块内存空间的内容是一样的。

重载赋值运算符正确的写法：
\begin{minted}{C++}
    MyString &MyString::operator=(const MyString &s) {
        if (str == s.str) return *this; // check self-assignment
        if (str) delete[] str;
        str = new char[strlen(s.str) + 1];
        strcpy(str, s.str);
        return *this;   // to chain this operator, eg x = y = z
    }
\end{minted}

复制构造函数正确的写法：
\begin{minted}{C++}
    MyString::MyString(const MyString &s) {
        if (s.str) {    // s is not NULL
            str = new char[strlen(s.str) + 1];  // + 1 for '\0'
            strcpy(str, s.str);
        } else {
            str = NULL;
        }
    }
\end{minted}

注意：在复制构造函数中，没有必要像重载赋值运算符函数中那样检查“自赋值”（相应地，这里指“自构造”）。
因为 \mintinline{C++}{int a = a;} 在 C++ 中是未定义的行为，就不应该出现，这种检查应该是编译器做的，而不是程序员
应该做的。\footnote{https://stackoverflow.com/questions/2529111/stdstring-xx}
\footnote{https://stackoverflow.com/questions/5517698/check-for-self-assignment-in-copy-constructor}

\subsubsection{重载赋值运算符时应该注意的问题}
重载赋值运算符的一般步骤：
\begin{enumerate}
    \item 检查“自赋值”，不检查自赋值可能会删除自身指针成员指向的内存。
    \item 删除原成员内容。如果包含动态内存，需要使用 \mintinline{C++}{delete}。
    \item 复制成员，这里和复制构造函数里的操作一致。如果涉及到动态内存，可以用 \mintinline{C++}{new} 进行深拷贝。
    \item 返回 \mintinline{C++}{*this}。根据赋值运算符原本的特性，返回值一般设置为引用。
\end{enumerate}

下面再详细地讨论一下返回值的问题。

返回值可以是 \mintinline{C++}{void} 吗？不行，考虑 \mintinline{C++}{a = b = c;} 如果返回值是
\mintinline{C++}{void}，\texttt{a} 就不不能被正确赋值，所以必须返回 \mintinline{C++}{*this}，以实现链式的表
达式。

返回值为什么是 \mintinline{C++}{MyString} 类型的引用呢？因为运算符重载时，我们希望尽量保留运算符原本的特性。例如
\mintinline{C++}{(a = b) = c;} 这个语句，等价于 \mintinline{C++}{(a.operator=(b)).operator=(c);} 按照赋
值运算符的特性是应该改变 \texttt{a} 的值的，如果不返回该类型的引用，\texttt{a} 的值就不会改变。

返回值可以是 \mintinline{C++}{MyString} 类型吗？可以，但是不好，原因上面已经提到，我们希望保留运算符原本的特性。
我在自己尝试这种实现时还遇到了其他的问题，和复制构造函数有关。重载赋值运算符是通过成员函数实现的，而我们返回的又是
\mintinline{C++}{*this}，即返回值是对象本身。前面学习复制构造函数时已经知道，一个类的对象作为函数的返回值，该函数返
回时会调用该类的复制构造函数，产生一个临时的对象。例如执行 \mintinline{C++}{s1 = s2;} 语句结束后，如果没有自己实现
复制构造函数，就会调用默认的复制构造函数，通过浅拷贝产生 \texttt{s1} 的一个临时拷贝对象。由于并没有哪个变量去承接这个
返回值，所以这个临时拷贝对象会立即调用析构函数并消亡。这时需要注意，在上面的例子中，由于没有自己实现深拷贝的复制构造函
数，临时拷贝对象中的指针成员和 \texttt{s1} 中的指针成员就会指向同一块动态内存，临时拷贝对象消亡时，析构函数会把它们共
同指向的这块动态内存删除。当 \texttt{s1} 对象也消亡时，会再次调用析构函数，可它指向的那块动态内存已经被删除了，这时就
会报错。将复制构造函数设计为深拷贝就可以避免这个问题，但是每次返回都会进行一次对象的拷贝和释放，返回引用会更高效。

\subsection{运算符重载为友元}
运算符可以被重载为类的成员函数和普通函数，通常我们会将运算符重载为类的成员函数。有些时候，成员函数不能满足使用要求，普通
函数又不能访问类的私有成员，这时候可以将运算符重载为友元函数。

\begin{minted}{C++}
    class Complex {
    private:
        double real, imag;
    public:
        Complex(double r, double i) : real(r), imag(i) {}
        Complex operator+(double r);
    };

    Complex Complex::operator+(double r) {
        return Complex(real + r, imag);
    }
\end{minted}

例如上面的代码定义了一个 \texttt{Complex} 类，并对 \texttt{+} 运算符进行了重载。经过上述重载后，可以对属于
\texttt{Complex} 类的对象 \texttt{c} 实现 \mintinline{C++}{c = c + 5;} 的操作，相当于
\mintinline{C++}{c = c.operator+(5);} 但是 \mintinline{C++}{c = 5 + c;} 就会编译出错。为了使
\mintinline{C++}{c = 5 + c;} 能成立，需要将 \texttt{+} 运算符重载为普通函数。

\begin{minted}{C++}
    Complex operator+(double r, const Complex &c) {
        return Complex(c.real + r, c.imag);
    }
\end{minted}

但是 \texttt{c.real} 和 \texttt{c.imag} 都是要访问对象 \texttt{c} 的私有成员，普通函数是没有访问权限的。所以要
把 \texttt{+} 运算符重载为友元函数。

\subsection{流插入运算符和流提取运算符的重载}
为什么 \mintinline{C++}{cout << 5 << "this";} 能够成立？

\texttt{cout} 是在 \texttt{iostream} 中定义的 \texttt{ostream} 类的对象。\mintinline{C++}{<<}
能用在 \mintinline{C++}{cout} 上是因为，在 \texttt{iostream} 里对 \texttt{<<} 进行了重载。

怎么样才能使 \mintinline{C++}{cout << 5;} 和 \mintinline{C++}{cout << "this"} 都能成立？
\mintinline{C++}{cout << 5;} 即 \mintinline{C++}{cout.operator<<(5);} \mintinline{C++}{cout << "this";}
即 \mintinline{C++}{cout.operator<<("this");} 所以该重载函数的返回值应该还是 \texttt{cout}。

\begin{minted}{C++}
    ostream &ostream::operator<<(int n) {
        ...
        return *this;
    }
\end{minted}

假定下面程序输出为 \texttt{5hello}，应该怎么重载 \texttt{<<} 运算符？
\begin{minted}{C++}
    class CStudent {
    public:
        int nAge;
    };

    int main(int argc, char const *argv[]) {
        CStudent s;
        s.nAge = 5;
        cout << s << "hello";   // 5hello
        return 0;
    }
\end{minted}

由于 \texttt{cout} 是 \texttt{ostream} 类的对象，而 \texttt{ostream} 是 \texttt{iostream} 中定义好的，所
以我们不能将 \texttt{<<} 重载为类的成员函数，只能将其重载为全局函数：
\begin{minted}{C++}
    ostream &operator<<(ostream &o, const CStudent &s) {
        o << s.nAge;
        return o;
    }
\end{minted}

假定 \texttt{c} 是 \texttt{Complex} 复数类的对象，现在希望写 \mintinline{C++}{cout << c;} 就能以
\texttt{a+bi} 的形式输出 \texttt{c} 的值，写 \mintinline{C++}{cin >> c;} 就能从键盘接受 \texttt{a+bi} 形
式的输入，并且使得 \texttt{c.real = a, c.imag = b}。
\begin{minted}{C++}
    class Complex {
    private:
        double real;
        double imag;
    public:
        Complex(double r = 0, double i = 0) : real(r), imag(i) {};
        friend ostream &operator<<(ostream &os, const Complex &c);
        friend istream &operator>>(istream &is, Complex &c);
    };

    ostream &operator<<(ostream &os, const Complex &c) {
        os << c.real << "+" << c.imag << "i";
        return os;
    }

    istream &operator>>(istream &is, Complex &c) {
        string s;
        is >> s;
        int pos = s.find("+", 0);
        string sTmp = s.substr(0, pos); // get real part
        c.real = atof(sTmp.c_str());    // convert const char * to float
        sTmp = s.substr(pos+1, s.length()-pos-2);   // get imaginary part
        c.imag = atof(sTmp.c_str());
        return is;
    }
\end{minted}

\subsection{自加、自减运算符的重载}
自加运算符 \texttt{++} 和自减运算符 \texttt{--} 有前置和后置之分。

前置运算符作为一元（单目）运算符重载：
\begin{itemize}
    \item 重载为成员函数
    \begin{minted}{C++}
    T operator++();
    T operator--();
    \end{minted}
    \item 重载为全局函数：
    \begin{minted}{C++}
    T operator++(T);
    T operator--(T);
    \end{minted}
\end{itemize}

\mintinline{C++}{++obj}、\mintinline{C++}{obj.operator++()}、\mintinline{C++}{operator++(obj)} 会调用
上述函数。

后置运算符是也是一元（单目）运算符。但是后置运算符和前置运算符都是单目的，名字又一样，所以为了在重载时区分后置运算符与
前置运算符，会引入一个多余的参数，将后置运算符作为二元（双目）运算符重载：
\begin{itemize}
    \item 重载为成员函数
    \begin{minted}{C++}
    T operator++(int);
    T operator--(int);
    \end{minted}
    \item 重载为全局函数
    \begin{minted}{C++}
    T operator++(T, int);
    T operator--(T, int);
    \end{minted}
\end{itemize}

\mintinline{C++}{obj++}、\mintinline{C++}{obj.operator++(0)}、\mintinline{C++}{operator++(obj, 0)}
会调用上述函数。

\begin{minted}{C++}
    class CDemo {
    private:
        int n;
    public:
        CDemo(int i = 0) : n(i) {}
        CDemo &operator++();    // prefix increment
        CDemo operator++(int);  // postfix increment
        operator int() {return n;}  // int cast overloading
        friend CDemo &operator--(CDemo &);      // prefix decrement
        friend CDemo operator--(CDemo &, int);  // postfix decrement
    };

    // prefix increment
    CDemo &CDemo::operator++() {
        n++;
        return *this;
    }

    // postfix increment
    CDemo CDemo::operator++(int k) {
        CDemo tmp(*this);
        n++;
        return tmp;
    }

    // prefix decrement
    CDemo &operator--(CDemo &d) {
        d.n--;
        return d;
    }

    // postfix decrement
    CDemo operator--(CDemo &d, int) {
        CDemo tmp(d);
        d.n--;
        return tmp;
    }
\end{minted}

其中 \mintinline{C++}|operator int() {return n;}| 语句是 \mintinline{C++}{int} 作为一个强制类型转换运算符
被重载。例如 \mintinline{C++}{Demo s; (int)s;}

类型强制转换运算符重载时，不能写返回值类型，实际上其返回值类型就是强制类型转换运算符代表的类型。

\subsection{运算符重载的注意事项}
\begin{itemize}
    \item C++ 不允许定义新的运算符
    \item 重载后运算符的含义应该符合日常习惯
    \begin{itemize}
        \item \mintinline{C++}{complex_a + complex_b}
        \item \mintinline{C++}{word_a > word_b}
        \item \mintinline{C++}{date_b = date_a + n}
    \end{itemize}
    \item 运算符重载不改变运算符的优先级
    \item 以下运算符不能被重载：\texttt{.}，\texttt{.*}，\texttt{::}，\texttt{? :}，\texttt{sizeof}
    \item 重载运算符 \texttt{()}、\texttt{[]}、\texttt{->} 或者 \texttt{=} 时，重载函数必须声明为类的成员函
    数
\end{itemize}

\end{document}
