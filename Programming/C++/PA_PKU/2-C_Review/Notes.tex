%-*- coding: UTF-8 -*-
% Notes.tex
%
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\geometry{a4paper, centering, scale=0.8}
\usepackage{minted}

\title{\heiti 《程序设计与算法》——《C 程序设计进阶》学习笔记}
\author{\kaishu Du Ang \\ \texttt{du2ang233@gmail.com} }
\date{\today}

\begin{document}
\maketitle

\section{《C 程序设计进阶》课程的主要内容}
\begin{itemize}
    \item 结构化的程序——函数
    \begin{itemize}
        \item 函数
        \item 递归
    \end{itemize}

    \item 更多的数据结构
    \begin{itemize}
        \item 指针
        \item 结构体
        \item 链表
    \end{itemize}
\end{itemize}

\section{C 程序中的函数}
\subsection{C 程序中常用的函数}
\begin{itemize}
    \item \mintinline{C++}{r = sqrt(100.0);}
    \item \mintinline{C++}{k = pow(x, y);}
    \item \mintinline{C++}{i = strlen(str1);}
    \item \mintinline{C++}{v = strcmp(str1, str2);}
    \item \mintinline{C++}{n = atoi(str1);}
\end{itemize}

\subsection{函数的调用方式}
\begin{enumerate}
    \item 作为独立语句\
    例如 \mintinline{C++}{stringPrint();}，调用函数完成某项功能，没有任何的返回值。
    \item 作为表达式的一部分
    例如 \mintinline{C++}{number = max(numA, numB) / 2;}
    \item 以实参形式出现在其他函数的调用中
    例如 \mintinline{C++}{min(sum(-5, 100), numC);}
\end{enumerate}

\subsection{函数是 C 程序的基本单位}
\texttt{main()} 函数是程序执行的入口，新的 C 语言标准要求 \texttt{main()} 函数需要有 \texttt{int} 类型的返回
值。

函数的类型是指“函数返回值的数据类型”。

函数的原型 = 返回值类型 + 函数名+ 参数类型

\subsection{参数的传递}
实参和形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”。函数调用时，系统给形参分配存储单元，并将实参对应的值
传递给形参。实参与形参的类型必须相同或可以兼容。

\subsection{数组与函数}
注意数组元素和数组名作为函数参数时的区别。
\begin{minted}{C++}
    void changeByElement(int a, int b)
    {
        a = 30;
        b = 50;
    }

    void changeByArrayName(int a[])
    {
        a[0] = 30;
        a[1] = 50;
    }

    int main(int argc, char const *argv[])
    {
        int a[2] = {3, 5};
        changeByElement(a[0], a[1]);
        cout << a[0] << " " << a[1] << endl;    // 3 5
        a[0] = 3;
        a[1] = 5;
        changeByArrayName(a);
        cout << a[0] << " " << a[1] << endl;    // 30 50
        return 0;
    }
\end{minted}

数组名不是变量，而是数组在内存中的一个地址，是一个常量。

\subsection{局部变量和全局变量}
\paragraph{局部变量}
在函数内或块内定义，只在这个函数或块内起作用的变量。
\paragraph{全局变量}
在所有函数外定义的变量，它的作用域是从定义变量的位置到本程序文件的结束。

全局变量的缺点：
\begin{itemize}
    \item 破坏了函数的“相对独立性”
    \item 增加了函数之间的“耦合性”
    \item 函数之间的交互不够清晰
\end{itemize}

不在非常必要的情况下，不要使用全局变量。

\section{Assignment 1}
\begin{minted}{C++}
    #include <iostream>
    #include <iomanip>

    int main()
    {
        std::cout << std::setfill('x') << std::setw(10);
        std::cout << 77 << std::endl;   // xxxxxxxx77
        std::cout << std::setfill('x') << std::setw(10) << right;
        std::cout << 77 << std::endl;   // xxxxxxxx77
        std::cout << std::setfill('x') << std::setw(10) << left;
        std::cout << 77 << std::endl;   // 77xxxxxxxx
        return 0;
    }
\end{minted}

\section{函数的递归}
函数不能嵌套定义，所有函数一律平等。

函数可以嵌套调用，无论嵌套多少层，原理都一样。

\subsection{用递归来完成递推}
递归和递推的不同点：
\begin{itemize}
    \item 递推的关注点放在起始条件上
    \item 递归的关注点放在求解目标上
\end{itemize}

递归和递推的相同点：
\begin{itemize}
    \item 都重在表现第 i 次和第 i+1 次的关系
\end{itemize}

用递归实现递推的典型案例：斐波那契数列，进制转换

用递归实现递推的优点：让程序变得简明。

用递归实现递推的方法：
\begin{itemize}
    \item 把关注点放在要求解的目标上
    \item 找到第 n 次做与第 n-1 次做之间的关系
    \item 确定第 1 次的返回结果
\end{itemize}

\subsection{用递归模拟连续发生的动作}
典型案例：汉诺塔问题

用递归模拟连续发生的动作的方法：
\begin{itemize}
    \item 搞清楚连续发生的动作是什么
    \begin{minted}{C++}
    void move(int m, char x, char y, char z);
    \end{minted}
    \item 搞清楚不同次动作之间的关系
    \begin{minted}{C++}
    move(m - 1, x, z, y);
    cout << "Move one plate from " << x << " to " << z << endl;
    move(m - 1, y, x, z);
    \end{minted}
    \item 搞清楚边界条件是什么
    \begin{minted}{C++}
    if (m == 1) {
        cout << "Move one plate from " << x << " to " << z endl;
    }
    \end{minted}
\end{itemize}

\subsection{用递归自动分析}
典型案例：逆波兰表达式，放苹果问题

用递归自动分析的方法：
\begin{itemize}
    \item 先假设有一个函数能给出答案
    \begin{minted}{C++}
    count(int m, int n)
    \end{minted}
    \item 在利用这个函数的前提下，分析如何解决问题
    \begin{minted}{C++}
    if (m < n)
        return count(m, m);
    else
        return count(m, n-1) + count(m-n, n);
    \end{minted}
    \item  搞清楚最简单的情况下的答案是什么
    \begin{minted}{C++}
    if (m <= 1 || n <= 1)
        return 1;
    \end{minted}
\end{itemize}

\section{指针}
\subsection{什么是指针}

把某个变量的地址称为“指向该变量的指针”。

可以通过取地址运算符 \texttt{\&} 来取到一个变量的地址。

计算机通过变量的地址（指针）操作变量，利用指针运算符 \texttt{*}。\texttt{*\&c} 等价于 \texttt{c}。在编译时，编译
器会建立变量名到地址的映射。

指针变量是专门用于存放指针（某个变量的地址）的变量。

定义一个指针变量：\mintinline{C++}{int *pointer;}

其中，\texttt{int} 是指针变量的基类型（指针变量指向的变量的类型），\texttt{*} 是指针运算符，表明了
\texttt{pointer} 的类型，\texttt{pointer} 是指针变量的名字。
\begin{minted}{C++}
    int c = 76;
    int *pointer;   // 定义名字为 pointer 的指针变量
    pointer = &c;   // 将变量 c 的地址赋给 pointer。赋值后，pointer 指向 c
    // pointer = c; // 错误！pointer 只能存放地址！
\end{minted}

指针变量也是变量，是变量就有地址。

\subsection{\& 与 * 的运算优先级}
后置++/- - > 前置++/- -、逻辑非（!）、*、\& > 算术运算符 > 关系运算符 > \&\&、|| > 赋值运算符

\begin{itemize}
    \item \mintinline{C++}{&*pointer = &(*pointer)}
    \item \mintinline{C++}{*&a= *(&a)}
    \item \mintinline{C++}{(*pointer)++} 不等于 \mintinline{C++}{*pointer++}
\end{itemize}

\subsection{\texttt{pointer++} 的含义}
\begin{minted}{C++}
#include <iostream>
using namespace std;
int main() {
    int n = 0;
    int *p = &n;
    cout << p << endl;  // 00C6FED8
    p++;
    cout << p << endl;  // 00C6FEDC
    return 0;
}
\end{minted}

假设：\texttt{iPtr} 当前所存的地址是 0x00000100
\begin{itemize}
    \item 若 \texttt{iPtr} 指向一个整型元素（占四个字节），则 \texttt{iPtr++} 等于
    \texttt{iPtr + 1 * 4 = 0x00000104}
    \item 若 \texttt{iPtr} 指向一个实型元素（占四个字节），则 \texttt{iPtr++} 等于
    \texttt{iPtr + 1 * 4 = 0x00000104}
    \item 若 \texttt{iPtr} 指向一个字符元素（占一个字节），则 \texttt{iPtr++} 等于
    \texttt{iPtr + 1 * 1 = 0x00000101}
\end{itemize}

\subsection{一维数组与指针}
\subsubsection{数组名是指向数组第一个元素的指针}
数组名代表数组首元素的地址，即 \emph{数组名是指向数组第一个元素的指针}。

例如，对于一个数组 \texttt{a[10]} 来说，数
组名 \texttt{a} 代表数组 \texttt{a[10]} 中第一个元素 \texttt{a[0]} 的地址，即 \texttt{a} 与 \texttt{\&a[0]}
等价。

注意：数组名 \texttt{a} 是地址常量，不是变量，不能给 \texttt{a} 赋值。

\subsubsection{利用指针变量引用数组元素}
若定义数组 \mintinline{C++}{int a[10];} 指针 \mintinline{C++}{int *pointer;}
则 \mintinline{C++}{pointer = a;} 等价于 \mintinline{C++}{pointer = &a[0];}

访问数组时，\mintinline{C++}{pointer + i} 等价于 \mintinline{C++}{a + i}，也等价于 \mintinline{C++}{&a[i]}。
\mintinline{C++}{*(pointer + i)} 等价于 \mintinline{C++}{*(a + i)}，也等价于 \mintinline{C++}{a[i]}。

在表示形式上，\mintinline{C++}{pointer[i]} 等价于 \mintinline{C++}{*(pointer + i)}。

需要注意的问题：
\begin{itemize}
    \item \mintinline{C++}{int *p = &a[0];}
    \begin{itemize}
        \item \mintinline{C++}{a++} 是没有意义的，但 \mintinline{C++}{p++} 会引起 \texttt{p} 变化。
        \item \texttt{p} 可以指向数组最后一个元素以后的元素。
    \end{itemize}
    \item 指针做加减运算时一定要注意有效的范围
    \begin{minted}{C++}
    int a[5];
    int *iPtr = &a[1];
    iPtr--;     // now iPtr points to a[0]
    *iPtr = 3;  // a[0] = 3
    iPtr--;     // now iPtr points to a[-1], dangerous
    *iPtr = 6;  // damage
    \end{minted}
    \item 指针与 ++/- - 的优先级问题 \\
    若定义 \mintinline{C++}{int a[5] = {1, 2, 3, 4, 5}; int *p;}
    设当前 \mintinline{C++}{i = 3; a[i] = 4;} 则
    \begin{itemize}
        \item \texttt{*++p} 相当于 \texttt{a[++i]}，先将 \texttt{p} 自加，再做 \texttt{*} 运算
        \item \texttt{*--p} 相当于 \texttt{a[--i]}，先使 \texttt{p} 自减，再做 \texttt{*} 运算
        \item \texttt{*p++} 相当于 \texttt{a[i++]}，先做 \texttt{*} 运算，再将 \texttt{p} 自加
        \item \texttt{*p--} 相当于 \texttt{a[i--]}，先做 \texttt{*} 运算，再将 \texttt{p} 自减
    \end{itemize}
\end{itemize}

\subsubsection{C 语言标准中关于数组的一些说明}
Types
\begin{quote}
    An \emph{array type} describes a contiguously allocated nonempty set of objects with a
    particular member object type, called the \emph{element type}. The element type shall be
    complete whenever the array type is specified. Array types are characterized by their element
    type and by the number of elements in the array. An array type is said to be derived from its
    element type, and if its element type is \emph{T}, the array type is sometimes called ``array of
    \emph{T}''. The construction of an array type from an element type is called ``array type
    derivation''.
\end{quote}

Lvalues\footnote{Lvalues and Rvalues (Visual C++), https://msdn.microsoft.com/en-us/library/f90831hc.aspx},
arrays, and function designators
\begin{quote}
    Except when it is the operand of the \texttt{sizeof} operator, the \texttt{\_Alignof} operator,
    or the unary \texttt{\&} operator, or is a string literal used to initialize an array, an
    expression that has type of ``array of \emph{type}'' is converted to an expression with type
    ``pointer to \emph{type}'' that points to the initial element of the array object and is not an
    lvalue. If the array object has register storage class, the behavior is undefined.
\end{quote}

Array subscripting
\begin{quote}
    A postfix expression followed by an expression in square brackets \texttt{[]} is a subscripted
    designation of an element of an array object. The definition of the subscript operator
    \texttt{[]} is that \texttt{E1[E2]} is indentical to \texttt{(*((E1)+(E2)))}. Because of the
    conversion rules that apply to the binary \texttt{+} operator, if \texttt{E1} is an array
    object (equivalently, a pointer to the inital element of an array object) and \texttt{E2} is an
    integer. \texttt{E1[E2]} designates the \texttt{E2-}th element of \texttt{E1} (counting from
    zero).
\end{quote}

例如定义了一个数组 \mintinline{C++}|int a[4] = {1, 3, 5, 7};| 则数组名 \texttt{a} 相当于指向数组第一个元素
\texttt{a[0]} 的指针，即 \texttt{a} 相当于 \texttt{\&a[0]}。
\begin{itemize}
    \item \texttt{\&a} 相当于管辖范围“上升”了一级
    \begin{itemize}
        \item \texttt{\&a} 是“指向数组”的指针；\texttt{\&a + 1} 将跨越 16 个字节
    \end{itemize}
    \item \texttt{*a} 相当于管辖范围“下降”了一级
    \begin{itemize}
        \item \texttt{*a} 是数组的第一个元素 \texttt{a[0]}；即 \texttt{*a} 等价于 \texttt{a[0]}
    \end{itemize}
\end{itemize}

\subsection{二维数组与指针}
定义 \mintinline{C++}|int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};|

二维数组 \texttt{a[3][4]} 包含三个元素：\texttt{a[0]}，\texttt{a[1]}，\texttt{a[2]}。每个元素都是一个“包含四
个整型元素”的一维数组。二维数组数组的第一个元素是 \texttt{a[0]}，\texttt{a[0]} 是一个“包含四个整型元素”的一维数
组。

二维数组 \texttt{a[3][4]} 的数组名 \texttt{a} 是指向数组第一个元素 \texttt{a[0]} 这个小数组的指针。而
\texttt{a[0]} 的含义是指向第一个小数组中第一个元素 \texttt{a[0][0]} 的指针。

推论：
\begin{itemize}
    \item \texttt{a} 与 \texttt{\&a[0]} 等价
    \item \texttt{a[0]} 与 \texttt{\&a[0][0]} 等价
    \item \texttt{a[0]} 与 \texttt{*a} 等价
    \item \texttt{a[0][0]} 与 \texttt{**a} 等价
\end{itemize}

三条规律：
\begin{itemize}
    \item 数组名相当于指向数组第一个元素的指针
    \item \texttt{\&E} 相当于把 \texttt{E} 的管辖范围上升了一个级别
    \item \texttt{*E} 相当于把 \texttt{E} 的管辖范围下降了一个级别
\end{itemize}


\end{document}
